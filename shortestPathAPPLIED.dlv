#show totalDistance/2.
#show suitableReceptionCenter/2.

volunteer(v1,"Mark Carter","Krakow").
volunteer(v2,"Mark Carter","Krakow").
preferredLocation(v1,"A",10).
preferredLocation(v2,"B",10).
preferredLocation(v3,"B",10).

receptionCenter(r1,"C",100).
receptionCenter(r2,"E",100).
receptionCenter(r3,"D",100).

city("A").
city("B").
city("C").
city("D").
city("E").

distance("A","B",5).
distance("A","C",2).
distance("A","D",3).
distance("D","B",1).
distance("D","E",2).
distance("C","E",1).

node(X) :- city(X). % city is a node
arc(X,Y,Cost) :- distance(X,Y,Cost). % The distance between two cities is the cost of the arc between them
arc(X,Y,Cost) :- arc(Y,X,Cost). % Double the arcs to make the graph undirected

start(V,X) :- preferredLocation(V,X,_). % The start node X is the preferred location of the volunteer V
end(RC,X) :- receptionCenter(RC,X,_). % The end node X is the reception center RC

% Guess and check, consider one node at a time for each volunteer as an end node X, the others will be considered as intermediate nodes
inRealEnd(V,RC,X) | outRealEnd(V,RC,X) :- end(RC,X), start(V,_). % The real end node is the reception center

% Guess and Check approach, to find all the paths from a node to another (from N1 to N2) for each preference of each volunteer
inPath(V,X,Y,Cost) | outPath(V,X,Y,Cost) :- arc(X,Y,Cost), preferredLocation(V,_,_).

%Only one RealEnd node for each volunteer
:- #count{V : inRealEnd(V,_,_)}=N, start(V,_), N!=1.

% Starting node X of the path for volunteer V
reached(V,X) :- start(V,X).

% Transition from one node to another for volunteer V
reached(V,X) :- inPath(V,Y,X,Cost), reached(V,Y).

% there must not be two arcs starting at the same node
:- inPath(V,X,Y,_), inPath(V,X,Y1,_), Y!=Y1.

% there must not be two arcs ending in the same node
:- inPath(V,X,Y,_), inPath(V,X1,Y,_), X!=X1.

% The path must reach the real end node
:- inRealEnd(V,_,X), not reached(V,X).

% Number of outward arcs for each reached node
outward(V,X,N) :- reached(V,X), #count{V,X,Y : inPath(V,X,Y,_)}=N.

% Number of inward arcs for each reached node
inward(V,Y,N) :- reached(V,Y), #count{V,X,Y : inPath(V,X,Y,_)}=N.

% The number of outward arcs from a RealEnd point must be less or equal to 1
:- outward(V,X,N), inRealEnd(V,_,X), N>0.

% The number of inward arcs in a RealEnd point must be zero
:- inward(V,X,N), inRealEnd(V,_,X), N<1.

% the number of outward arcs and inward arcs from start is less or equal to 1
:- inward(V,X,N), outward(V,X,M), start(V,X), N+M>1.

% don't include in path if the node has not been reached
:- inPath(V,X,Y,_), not reached(V,Y).

% Total distance X to be traveled by each volunteer V
totalDistance(V,X) :- #sum{C,V,A,B : inPath(V,A,B,C)}=X, start(V,_).

% The volunteer V is assigned to a Reception Center RC within a range of distance X from the preferred location of the volunteer.
suitableReceptionCenter(V,RC) :- inRealEnd(V,RC,_), totalDistance(V,X), preferredLocation(V,_,MaxRange), X<=MaxRange.

%Number of all volunteers with preferred Location
totalVolunteers(N) :- #count{V : preferredLocation(V,_,_)}=N.

% Maximize the number of volunteers able to be assigned to a reception center (high priority)
% Pay for each volunteer not suitable for a reception center (who can't be assigned to a reception center)
:~ #count{V,RC : suitableReceptionCenter(V,RC)}=X, totalVolunteers(N), Z=N-X. [Z@2]
%:~ volunteer(V,_,_), not suitableReceptionCenter(V,RC), receptionCenter(RC,_,_). [1@2,V]

% Minimize the distance traveled by each volunteer
% Pay for the distance traveled by each volunteer, who is suitable for a reception center
:~ totalDistance(V,Cost), suitableReceptionCenter(V,_). [Cost@1,V]




