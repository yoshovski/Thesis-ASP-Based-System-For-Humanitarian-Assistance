% #show inPath/3.
% #show reached/1.
% #show totalDistance/1.
% #show bestLocation/1.

% city("A").
% city("B").
% city("C").
% city("D").
% city("E").

% distance("A","B",5).
% distance("A","C",2).
% distance("A","D",3).
% distance("D","B",1).
% distance("D","E",2).
% distance("C","E",1).

% distance(X,Y,Z) :- distance(Y,X,Z).

% start("B").
% start("A").
% end("C").
% end("E").

%%% Shortest Path from start to end (passing through all end points)
% inPath(X,Y,C) | outPath(X,Y,C) :- distance(X,Y,C).
% reached(X) :- start(X).
% reached(X) :- inPath(Y,X,C), reached(Y).
% :- inPath(X,Y,_), inPath(X,Y1,_), Y!=Y1.
% :- inPath(X,Y,_), inPath(X1,Y,_), X!=X1.
% :- end(X), not reached(X).
% :~ inPath(X,Y,C). [C@1,X]

%%% Shortest Path between start and end (more end points possible, only one end point will be chosen)
% inPath(X,Y,C) | outPath(X,Y,C) :- distance(X,Y,C).
% reached(X) :- start(X).
% reached(X) :- inPath(Y,X,C), reached(Y).
% :- inPath(X,Y,_), inPath(X,Y1,_), Y!=Y1.
% :- inPath(X,Y,_), inPath(X1,Y,_), X!=X1.
% :- #count{X : end(X), reached(X)}=Y, Y!=1. % Only one end point reached
% totalDistance(X) :- #sum{C,A,B : inPath(A,B,C)}=X. 
% bestLocation(X) :- end(X), reached(X).
%:~ inPath(X,Y,C). [C@1,X,Y]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% NEW APPROACH
% inRealStart(Start) | outRealStart(Start) :- start(Start).
% inRealEnd(End) | outRealEnd(End) :- end(End).

% :- #count{X : inRealStart(X)}=Z, Z!=1.
% :- #count{X : inRealEnd(X)}=Z, Z!=1.

% inPath(X,Y,C) | outPath(X,Y,C) :- distance(X,Y,C).
% reached(X) :- inRealStart(X).
% reached(X) :- inPath(Y,X,C), reached(Y).
% :- inPath(X,Y,_), inPath(X,Y1,_), Y!=Y1.
% :- inPath(X,Y,_), inPath(X1,Y,_), X!=X1.
% :- inRealEnd(X), not reached(X).
% totalDistance(X) :- #sum{C,A,B : inPath(A,B,C)}=X. 
% bestLocation(X) :- inRealEnd(X), reached(X).
%:~ inPath(X,Y,C). [C@1,X,Y]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Optimized Approach (PREFERRED)
% Shortest Path among all possible paths between start and end, only one path will be chosen (one start and one end point)

% inRealStart(Start) | outRealStart(Start) :- start(Start).
% inRealEnd(End) | outRealEnd(End) :- end(End).

% :- #count{X : inRealStart(X)}=Z, Z!=1.
% :- #count{X : inRealEnd(X)}=Z, Z!=1.

% inPath(X,Y,C) | outPath(X,Y,C) :- distance(X,Y,C).
% reached(X) :- inRealStart(X).
% reached(X) :- inPath(Y,X,C), reached(Y).

% % there must not be two arcs starting at the same node
% :- inPath(X,Y,_), inPath(X,Y1,_), Y!=Y1.

% % there must not be two arcs ending at the same node
% :- inPath(X,Y,_), inPath(X1,Y,_), X!=X1.

% % there aren't outward arcs from Real End node
% :- inPath(X,Y,_), inRealEnd(X).

% % there aren't inward arcs to Real Start node
% :- inPath(X,Y,_), inRealStart(Y).

% % The path must reach the real end node
% :- inRealEnd(X), not reached(X).

% % don't include in path if the node has not been reached
% :- inPath(X,Y,_), not reached(Y).

% :~ inPath(X,Y,C). [C@1,X,Y]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Optimized Approach Applied with Volunteers (WORKING)

city("A").
city("B").
city("C").
city("D").
city("E").

distance("A","B",5).
distance("A","C",2).
distance("A","D",3).
distance("D","B",1).
distance("D","E",2).
distance("C","E",1).

distance(X,Y,Z) :- distance(Y,X,Z).


maxLocationRange(v1,"A",20).
maxLocationRange(v2,"B",4).

% preferredLocation(v1,"A",10).
% preferredLocation(v2,"B",10).

receptionCenter(r1,"C",100).
receptionCenter(r2,"E",100).


node(X) :- city(X). % city is a node
arc(X,Y,Cost) :- distance(X,Y,Cost). % The distance between two cities is the cost of the arc between them
arc(X,Y,Cost) :- arc(Y,X,Cost). % Double the arcs to make the graph undirected

start(V,X) :- maxLocationRange(V,X,_). % The start node X is the preferred location of the volunteer V
end(X) :- receptionCenter(_,X,_). % The end node X is the reception center RC

inRealStart(V,Start) | outRealStart(V,Start) :- start(V,Start).
inRealEnd(End) | outRealEnd(End) :- end(End).

:- #count{X : inRealStart(V,X)}=Z, Z!=1.
:- #count{X : inRealEnd(X)}=Z, Z!=1.

inPath(V,X,Y,C) | outPath(V,X,Y,C) :- arc(X,Y,C), start(V,_).
reached(V,X) :- inRealStart(V,X).
reached(V,X) :- inPath(V,Y,X,C), reached(V,Y).

% there must not be two arcs starting at the same node
:- inPath(V,X,Y,_), inPath(V,X,Y1,_), Y!=Y1.

% there must not be two arcs ending at the same node
:- inPath(V,X,Y,_), inPath(V,X1,Y,_), X!=X1.

% there aren't outward arcs from Real End node
:- inPath(V,X,Y,_), inRealEnd(X).

% there aren't inward arcs to Real Start node
:- inPath(V,X,Y,_), inRealStart(V,Y).

% The path must reach the real end node
:- inRealEnd(X), not reached(V,X), inRealStart(V,_).

% don't include in path if the node has not been reached
:- inPath(V,X,Y,_), not reached(V,Y).

% Total distance travelled
totalDistance(X) :- #sum{C,V,A,B : inPath(V,A,B,C)}=X.

% The distance travelled must be less than the maximum range of the volunteer
% The distance travelled from start location of the volunteer, must be less than the maximum km range requirement of the volunteer
:- totalDistance(X), maxLocationRange(V,_,Y), inRealStart(V,_), X>Y. 

#show withinRange/3.
% preferredLocation(VolunteerID, Location, Distance).
% Volunteer -> Id of the volunteer for which the distance from (start to end) the preferred location to the reception center is calculated
% Location -> The end node of the path (the reception center)
% Distance -> The distance from the preferred location of the volunteer to the reception center (the cost)

withinRange(X,L,D) :- inRealStart(V,X), inRealEnd(L), totalDistance(D).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%distantFrom(V,L) :- inRealStart(V,_), inRealEnd(L).

% distantFrom(v2,"E",3).
% distantFrom(v2,"C",4).
% distantFrom(v1,"E",8).
% distantFrom(v1,"E",5).
% distantFrom(v1,"E",3).
% distantFrom(v1,"C",9).
% distantFrom(v1,"C",6).
% distantFrom(v1,"C",2).

% shortestUniquePath(V,L,D) :- distantFrom(V,L,_), #min{X,V,L : distantFrom(V,L,X)}=D.